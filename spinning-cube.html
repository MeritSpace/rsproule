<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spinning 3D Cube with Physics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            perspective: 1000px;
            overflow: hidden;
        }

        .scene {
            width: 200px;
            height: 200px;
            perspective: 600px;
            position: absolute;
        }

        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
        }

        .face {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            backface-visibility: visible;
        }

        .front {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.8), rgba(255, 107, 107, 0.4));
            transform: translateZ(100px);
            box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);
        }

        .back {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.8), rgba(78, 205, 196, 0.4));
            transform: rotateY(180deg) translateZ(100px);
            box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);
        }

        .right {
            background: linear-gradient(135deg, rgba(69, 183, 209, 0.8), rgba(69, 183, 209, 0.4));
            transform: rotateY(90deg) translateZ(100px);
            box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);
        }

        .left {
            background: linear-gradient(135deg, rgba(150, 111, 214, 0.8), rgba(150, 111, 214, 0.4));
            transform: rotateY(-90deg) translateZ(100px);
            box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);
        }

        .top {
            background: linear-gradient(135deg, rgba(247, 215, 148, 0.8), rgba(247, 215, 148, 0.4));
            transform: rotateX(90deg) translateZ(100px);
            box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);
        }

        .bottom {
            background: linear-gradient(135deg, rgba(119, 221, 119, 0.8), rgba(119, 221, 119, 0.4));
            transform: rotateX(-90deg) translateZ(100px);
            box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);
        }

        .glow {
            position: absolute;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50px, -50px);
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: float 15s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .mouse-cursor {
            position: fixed;
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out, border-color 0.2s;
            z-index: 1000;
        }

        .mouse-cursor.colliding {
            border-color: rgba(255, 107, 107, 1);
            transform: translate(-50%, -50%) scale(1.2);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            z-index: 1000;
        }

        .info span {
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    <div class="mouse-cursor" id="mouseCursor"></div>
    <div class="scene" id="scene">
        <div class="glow" id="glow"></div>
        <div class="cube" id="cube">
            <div class="face front">FRONT</div>
            <div class="face back">BACK</div>
            <div class="face right">RIGHT</div>
            <div class="face left">LEFT</div>
            <div class="face top">TOP</div>
            <div class="face bottom">BOTTOM</div>
        </div>
    </div>
    <div class="info">
        <span>Velocity: <span id="velocityDisplay">0, 0</span></span>
        <span>Position: <span id="positionDisplay">0, 0</span></span>
        <span>Move mouse to interact with cube</span>
    </div>

    <script>
        // Create floating particles
        const particlesContainer = document.getElementById('particles');
        const particleCount = 50;

        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (10 + Math.random() * 10) + 's';
            particle.style.width = (2 + Math.random() * 4) + 'px';
            particle.style.height = particle.style.width;
            particle.style.opacity = 0.3 + Math.random() * 0.5;
            particlesContainer.appendChild(particle);
        }

        // Physics Engine
        const scene = document.getElementById('scene');
        const cube = document.getElementById('cube');
        const glow = document.getElementById('glow');
        const mouseCursor = document.getElementById('mouseCursor');
        const velocityDisplay = document.getElementById('velocityDisplay');
        const positionDisplay = document.getElementById('positionDisplay');

        // Physics constants
        const GRAVITY = 300;
        const FRICTION = 0.99;
        const BOUNCE_DAMPING = 0.75;
        const MOUSE_RADIUS = 30; // Mouse cursor collision radius
        const CUBE_SIZE = 200;
        const CUBE_HALF = CUBE_SIZE / 2;

        // Physics state
        let physics = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            vx: 150,
            vy: -200,
            ax: 0,
            ay: GRAVITY,
            rotationX: 0,
            rotationY: 0,
            rotationZ: 0,
            angularVelX: 2,
            angularVelY: 3,
            angularVelZ: 0.5
        };

        let mouse = {
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0,
            vx: 0,
            vy: 0,
            active: false
        };

        let lastTime = performance.now();

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.active = true;
            mouseCursor.style.left = e.clientX + 'px';
            mouseCursor.style.top = e.clientY + 'px';
        });

        document.addEventListener('mouseleave', () => {
            mouse.active = false;
        });

        document.addEventListener('mouseenter', () => {
            mouse.active = true;
        });

        // Click to give the cube a push
        document.addEventListener('click', (e) => {
            const dx = physics.x - e.clientX;
            const dy = physics.y - e.clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
                physics.vx += (dx / dist) * 500;
                physics.vy += (dy / dist) * 500;
            }
        });

        // Find closest point on cube to a given point
        function closestPointOnCube(px, py, cubeX, cubeY, halfSize) {
            const clampedX = Math.max(cubeX - halfSize, Math.min(cubeX + halfSize, px));
            const clampedY = Math.max(cubeY - halfSize, Math.min(cubeY + halfSize, py));
            return { x: clampedX, y: clampedY };
        }

        function checkMouseCollision() {
            if (!mouse.active) return { colliding: false };

            // Find closest point on cube to mouse center
            const closest = closestPointOnCube(mouse.x, mouse.y, physics.x, physics.y, CUBE_HALF);

            // Calculate distance from mouse center to closest point on cube
            const dx = mouse.x - closest.x;
            const dy = mouse.y - closest.y;
            const distSq = dx * dx + dy * dy;

            // Check if mouse circle intersects with cube
            if (distSq < MOUSE_RADIUS * MOUSE_RADIUS) {
                const dist = Math.sqrt(distSq);

                // Handle case where mouse is inside the cube
                if (dist < 0.001) {
                    // Mouse is exactly at or inside the cube - push based on relative position
                    const relX = physics.x - mouse.x;
                    const relY = physics.y - mouse.y;
                    const relDist = Math.sqrt(relX * relX + relY * relY);
                    if (relDist < 0.001) {
                        // Mouse at exact center - push in random direction
                        return {
                            colliding: true,
                            nx: Math.random() - 0.5,
                            ny: Math.random() - 0.5,
                            overlap: MOUSE_RADIUS + CUBE_HALF,
                            closestX: closest.x,
                            closestY: closest.y
                        };
                    }
                    return {
                        colliding: true,
                        nx: relX / relDist,
                        ny: relY / relDist,
                        overlap: MOUSE_RADIUS + CUBE_HALF - relDist,
                        closestX: closest.x,
                        closestY: closest.y
                    };
                }

                // Normal collision - push cube away from mouse
                // Normal points from mouse toward cube
                const nx = -dx / dist;
                const ny = -dy / dist;
                const overlap = MOUSE_RADIUS - dist;

                return {
                    colliding: true,
                    nx: nx,
                    ny: ny,
                    overlap: overlap,
                    closestX: closest.x,
                    closestY: closest.y
                };
            }

            return { colliding: false };
        }

        function resolveMouseCollision(collision) {
            // Separate the cube from the mouse
            physics.x += collision.nx * collision.overlap * 1.01;
            physics.y += collision.ny * collision.overlap * 1.01;

            // Calculate relative velocity (cube velocity minus mouse velocity)
            const relVx = physics.vx - mouse.vx;
            const relVy = physics.vy - mouse.vy;

            // Calculate relative velocity along collision normal
            const relVelAlongNormal = relVx * collision.nx + relVy * collision.ny;

            // Only resolve if objects are moving toward each other
            if (relVelAlongNormal < 0) {
                // Calculate impulse scalar with restitution (bounciness)
                const restitution = BOUNCE_DAMPING;
                const impulse = -(1 + restitution) * relVelAlongNormal;

                // Apply impulse to cube velocity
                physics.vx += impulse * collision.nx;
                physics.vy += impulse * collision.ny;

                // Transfer some mouse velocity to cube (gives it a "push" feel)
                physics.vx += mouse.vx * 0.3;
                physics.vy += mouse.vy * 0.3;
            }

            // Add spin based on collision point relative to cube center
            const collisionOffsetX = collision.closestX - physics.x;
            const collisionOffsetY = collision.closestY - physics.y;

            // Cross product for angular impulse
            const torque = (collisionOffsetX * collision.ny - collisionOffsetY * collision.nx) * 0.02;
            physics.angularVelZ += torque;
            physics.angularVelX += collisionOffsetY * 0.01;
            physics.angularVelY -= collisionOffsetX * 0.01;
        }

        function checkWallCollision() {
            const margin = CUBE_HALF;
            let collided = false;

            // Left wall
            if (physics.x - margin < 0) {
                physics.x = margin;
                physics.vx = Math.abs(physics.vx) * BOUNCE_DAMPING;
                physics.angularVelY += physics.vy * 0.01;
                collided = true;
            }
            // Right wall
            if (physics.x + margin > window.innerWidth) {
                physics.x = window.innerWidth - margin;
                physics.vx = -Math.abs(physics.vx) * BOUNCE_DAMPING;
                physics.angularVelY -= physics.vy * 0.01;
                collided = true;
            }
            // Top wall
            if (physics.y - margin < 0) {
                physics.y = margin;
                physics.vy = Math.abs(physics.vy) * BOUNCE_DAMPING;
                physics.angularVelX -= physics.vx * 0.01;
                collided = true;
            }
            // Bottom wall
            if (physics.y + margin > window.innerHeight) {
                physics.y = window.innerHeight - margin;
                physics.vy = -Math.abs(physics.vy) * BOUNCE_DAMPING;
                physics.angularVelX += physics.vx * 0.01;
                collided = true;
            }

            return collided;
        }

        function update(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
            lastTime = currentTime;

            // Update mouse velocity (smoothed)
            if (dt > 0) {
                const rawVx = (mouse.x - mouse.prevX) / dt;
                const rawVy = (mouse.y - mouse.prevY) / dt;
                // Smooth mouse velocity with exponential moving average
                mouse.vx = mouse.vx * 0.7 + rawVx * 0.3;
                mouse.vy = mouse.vy * 0.7 + rawVy * 0.3;
                mouse.prevX = mouse.x;
                mouse.prevY = mouse.y;
            }

            // Apply gravity
            physics.vx += 0; // No horizontal acceleration from gravity
            physics.vy += GRAVITY * dt;

            // Apply friction
            physics.vx *= FRICTION;
            physics.vy *= FRICTION;

            // Update position
            physics.x += physics.vx * dt;
            physics.y += physics.vy * dt;

            // Check wall collisions first
            checkWallCollision();

            // Check and resolve mouse collision
            const mouseCollision = checkMouseCollision();
            if (mouseCollision.colliding) {
                mouseCursor.classList.add('colliding');
                resolveMouseCollision(mouseCollision);
            } else {
                mouseCursor.classList.remove('colliding');
            }

            // Re-check walls after mouse collision resolution
            checkWallCollision();

            // Update rotation based on angular velocity
            physics.rotationX += physics.angularVelX * dt * 60;
            physics.rotationY += physics.angularVelY * dt * 60;
            physics.rotationZ += physics.angularVelZ * dt * 60;

            // Dampen angular velocity slowly
            physics.angularVelX *= 0.998;
            physics.angularVelY *= 0.998;
            physics.angularVelZ *= 0.998;

            // Apply transforms
            scene.style.left = physics.x + 'px';
            scene.style.top = physics.y + 'px';
            scene.style.transform = `translate(-50%, -50%)`;

            cube.style.transform = `rotateX(${physics.rotationX}deg) rotateY(${physics.rotationY}deg) rotateZ(${physics.rotationZ}deg)`;

            // Update display
            velocityDisplay.textContent = `${physics.vx.toFixed(0)}, ${physics.vy.toFixed(0)}`;
            positionDisplay.textContent = `${physics.x.toFixed(0)}, ${physics.y.toFixed(0)}`;

            requestAnimationFrame(update);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            // Keep cube within bounds after resize
            physics.x = Math.max(CUBE_HALF, Math.min(window.innerWidth - CUBE_HALF, physics.x));
            physics.y = Math.max(CUBE_HALF, Math.min(window.innerHeight - CUBE_HALF, physics.y));
        });

        // Start the physics loop
        requestAnimationFrame(update);
    </script>
</body>
</html>
