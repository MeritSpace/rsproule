<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tekkers - 3D Cube Juggling</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        #score {
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }
        #high-score {
            font-size: 18px;
            color: #888;
            margin-top: 5px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            pointer-events: auto;
        }
        #message h1 {
            font-size: 64px;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }
        #message p {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 30px;
        }
        #start-btn {
            padding: 15px 50px;
            font-size: 24px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            border: none;
            border-radius: 50px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }
        #game-over {
            display: none;
        }
        #game-over h1 {
            color: #ff4444;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui">
            <div id="score">0</div>
            <div id="high-score">Best: 0</div>
        </div>
        <div id="message">
            <h1>TEKKERS</h1>
            <p>Juggle the cube with your paddle!</p>
            <button id="start-btn">START</button>
        </div>
        <div id="game-over" style="display: none;">
            <h1>GAME OVER</h1>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="restart-btn">PLAY AGAIN</button>
        </div>
        <div id="instructions">Move mouse left/right to control paddle</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game constants
        const GRAVITY = -25;
        const BOUNCE_DAMPING = 0.75;
        const CUBE_SIZE = 1.5;
        const PADDLE_WIDTH = 4;
        const PADDLE_HEIGHT = 0.4;
        const PADDLE_DEPTH = 2;
        const GAME_WIDTH = 16;
        const GAME_HEIGHT = 20;
        const PADDLE_Y = -8;
        const FLOOR_Y = -10;
        const SPIN_TRANSFER = 0.3;

        // Game state
        let scene, camera, renderer;
        let cube, paddle, floor;
        let cubeVelocity = { x: 0, y: 0, z: 0 };
        let cubeAngularVelocity = { x: 0, y: 0, z: 0 };
        let score = 0;
        let highScore = localStorage.getItem('tekkersHighScore') || 0;
        let gameRunning = false;
        let mouseX = 0;
        let lastPaddleX = 0;
        let paddleVelocityX = 0;

        // DOM elements
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('high-score');
        const messageDiv = document.getElementById('message');
        const gameOverDiv = document.getElementById('game-over');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const finalScoreSpan = document.getElementById('final-score');

        // Initialize Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 15, 40);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 18);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -15;
            mainLight.shadow.camera.right = 15;
            mainLight.shadow.camera.top = 15;
            mainLight.shadow.camera.bottom = -15;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x00ff88, 0.3);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);

            // Create cube
            const cubeGeometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const cubeMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                metalness: 0.3,
                roughness: 0.4,
                emissive: 0x00ff88,
                emissiveIntensity: 0.1
            });
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);

            // Add edges to cube for better visibility
            const edges = new THREE.EdgesGeometry(cubeGeometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
            cube.add(edgeLines);

            // Create paddle
            const paddleGeometry = new THREE.BoxGeometry(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH);
            const paddleMaterial = new THREE.MeshStandardMaterial({
                color: 0x4444ff,
                metalness: 0.5,
                roughness: 0.3,
                emissive: 0x4444ff,
                emissiveIntensity: 0.2
            });
            paddle = new THREE.Mesh(paddleGeometry, paddleMaterial);
            paddle.position.y = PADDLE_Y;
            paddle.castShadow = true;
            paddle.receiveShadow = true;
            scene.add(paddle);

            // Create floor (danger zone)
            const floorGeometry = new THREE.PlaneGeometry(GAME_WIDTH * 2, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xff2222,
                transparent: true,
                opacity: 0.3,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = FLOOR_Y;
            scene.add(floor);

            // Add boundary walls (visual only)
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x333355,
                transparent: true,
                opacity: 0.2
            });

            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(1, GAME_HEIGHT), wallMaterial);
            leftWall.position.set(-GAME_WIDTH / 2, 0, 0);
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(1, GAME_HEIGHT), wallMaterial);
            rightWall.position.set(GAME_WIDTH / 2, 0, 0);
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);

            // Grid helper for depth perception
            const gridHelper = new THREE.GridHelper(30, 30, 0x333355, 0x222244);
            gridHelper.position.y = FLOOR_Y - 0.1;
            scene.add(gridHelper);

            // Update high score display
            highScoreDisplay.textContent = `Best: ${highScore}`;

            // Event listeners
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', startGame);

            // Start render loop
            animate();
        }

        function onMouseMove(event) {
            // Map mouse position to game world coordinates
            const normalizedX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseX = normalizedX * (GAME_WIDTH / 2 - PADDLE_WIDTH / 2);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            // Reset cube position and velocity
            cube.position.set(
                (Math.random() - 0.5) * 6,
                8,
                0
            );
            cubeVelocity = {
                x: (Math.random() - 0.5) * 3,
                y: 0,
                z: 0
            };
            cubeAngularVelocity = {
                x: (Math.random() - 0.5) * 2,
                y: (Math.random() - 0.5) * 2,
                z: (Math.random() - 0.5) * 2
            };
            cube.rotation.set(0, 0, 0);

            // Reset score
            score = 0;
            scoreDisplay.textContent = '0';

            // Hide menus
            messageDiv.style.display = 'none';
            gameOverDiv.style.display = 'none';

            // Start game
            gameRunning = true;
        }

        function gameOver() {
            gameRunning = false;

            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('tekkersHighScore', highScore);
                highScoreDisplay.textContent = `Best: ${highScore}`;
            }

            // Show game over screen
            finalScoreSpan.textContent = score;
            gameOverDiv.style.display = 'block';
            gameOverDiv.querySelector('h1').textContent = 'GAME OVER';
            gameOverDiv.querySelector('p').innerHTML = `Final Score: <span id="final-score">${score}</span>`;

            // Style game over div
            gameOverDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                z-index: 100;
            `;
            gameOverDiv.querySelector('h1').style.cssText = `
                font-size: 64px;
                color: #ff4444;
                margin-bottom: 20px;
                text-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
            `;
            gameOverDiv.querySelector('p').style.cssText = `
                font-size: 24px;
                color: #aaa;
                margin-bottom: 30px;
            `;

            // Style restart button
            const restartBtn = gameOverDiv.querySelector('#restart-btn');
            restartBtn.style.cssText = `
                padding: 15px 50px;
                font-size: 24px;
                background: linear-gradient(135deg, #00ff88, #00cc6a);
                border: none;
                border-radius: 50px;
                color: #1a1a2e;
                font-weight: bold;
                cursor: pointer;
            `;
        }

        function checkCollision() {
            const cubeHalfSize = CUBE_SIZE / 2;
            const cubeBottom = cube.position.y - cubeHalfSize;
            const cubeTop = cube.position.y + cubeHalfSize;
            const cubeLeft = cube.position.x - cubeHalfSize;
            const cubeRight = cube.position.x + cubeHalfSize;

            const paddleTop = paddle.position.y + PADDLE_HEIGHT / 2;
            const paddleBottom = paddle.position.y - PADDLE_HEIGHT / 2;
            const paddleLeft = paddle.position.x - PADDLE_WIDTH / 2;
            const paddleRight = paddle.position.x + PADDLE_WIDTH / 2;

            // Check if cube is colliding with paddle
            if (cubeBottom <= paddleTop &&
                cubeBottom >= paddleBottom - 0.5 &&
                cubeRight >= paddleLeft &&
                cubeLeft <= paddleRight &&
                cubeVelocity.y < 0) {

                // Calculate where on paddle the cube hit (-1 to 1)
                const hitPosition = (cube.position.x - paddle.position.x) / (PADDLE_WIDTH / 2);

                // Bounce the cube
                cube.position.y = paddleTop + cubeHalfSize;

                // Base bounce velocity
                let bounceVelocity = Math.abs(cubeVelocity.y) * BOUNCE_DAMPING;
                bounceVelocity = Math.max(bounceVelocity, 8); // Minimum bounce
                bounceVelocity = Math.min(bounceVelocity, 20); // Maximum bounce

                cubeVelocity.y = bounceVelocity;

                // Add horizontal velocity based on hit position and paddle movement
                cubeVelocity.x += hitPosition * 3 + paddleVelocityX * 0.5;
                cubeVelocity.x = Math.max(-10, Math.min(10, cubeVelocity.x)); // Clamp

                // Add spin based on paddle velocity
                cubeAngularVelocity.z -= paddleVelocityX * SPIN_TRANSFER;
                cubeAngularVelocity.x += (Math.random() - 0.5) * 2;

                // Increment score
                score++;
                scoreDisplay.textContent = score;

                // Visual feedback - pulse the cube
                cube.material.emissiveIntensity = 0.5;
                setTimeout(() => {
                    if (cube.material) cube.material.emissiveIntensity = 0.1;
                }, 100);

                return true;
            }
            return false;
        }

        function update(deltaTime) {
            if (!gameRunning) return;

            // Update paddle position smoothly
            const targetX = Math.max(-GAME_WIDTH / 2 + PADDLE_WIDTH / 2,
                Math.min(GAME_WIDTH / 2 - PADDLE_WIDTH / 2, mouseX));

            paddleVelocityX = (targetX - paddle.position.x) / deltaTime;
            paddle.position.x += (targetX - paddle.position.x) * 0.3;

            // Apply gravity
            cubeVelocity.y += GRAVITY * deltaTime;

            // Update cube position
            cube.position.x += cubeVelocity.x * deltaTime;
            cube.position.y += cubeVelocity.y * deltaTime;
            cube.position.z += cubeVelocity.z * deltaTime;

            // Update cube rotation
            cube.rotation.x += cubeAngularVelocity.x * deltaTime;
            cube.rotation.y += cubeAngularVelocity.y * deltaTime;
            cube.rotation.z += cubeAngularVelocity.z * deltaTime;

            // Dampen angular velocity slightly
            cubeAngularVelocity.x *= 0.995;
            cubeAngularVelocity.y *= 0.995;
            cubeAngularVelocity.z *= 0.995;

            // Wall collisions
            const cubeHalfSize = CUBE_SIZE / 2;
            if (cube.position.x - cubeHalfSize < -GAME_WIDTH / 2) {
                cube.position.x = -GAME_WIDTH / 2 + cubeHalfSize;
                cubeVelocity.x = -cubeVelocity.x * 0.8;
                cubeAngularVelocity.y += cubeVelocity.x * 0.1;
            }
            if (cube.position.x + cubeHalfSize > GAME_WIDTH / 2) {
                cube.position.x = GAME_WIDTH / 2 - cubeHalfSize;
                cubeVelocity.x = -cubeVelocity.x * 0.8;
                cubeAngularVelocity.y -= cubeVelocity.x * 0.1;
            }

            // Keep cube in z bounds
            if (Math.abs(cube.position.z) > 2) {
                cube.position.z = Math.sign(cube.position.z) * 2;
                cubeVelocity.z = -cubeVelocity.z * 0.5;
            }

            // Check paddle collision
            checkCollision();

            // Check if cube fell below floor
            if (cube.position.y - cubeHalfSize < FLOOR_Y) {
                gameOver();
            }

            // Ceiling bounce
            if (cube.position.y + cubeHalfSize > 12) {
                cube.position.y = 12 - cubeHalfSize;
                cubeVelocity.y = -Math.abs(cubeVelocity.y) * 0.5;
            }

            lastPaddleX = paddle.position.x;
        }

        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);

            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (deltaTime > 0) {
                update(deltaTime);
            }

            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
